1、忘记释放
2、局部变量写成全局变量
3、存在其他引用

两种方法
1、遍历_G，记录所有对象，在程序执行之后执行几次GC操作，
然后再进行一次搜索，对比两次的结果，多出来的那些就有可能是内存泄露了。

2、我们可以创建一个全局的弱引用table，使其key为弱引用，然后在每次创建
那些可能存在泄漏的对象的时候，都放入这个table，让其作为key，value通常
我会用当前时间。由于弱引用的性质，如果其他引用都消失了，那么在弱引用
table中对这个对象的引用也会消失（变成nil），反之，只要还有其它任何一个
引用存在，这个弱引用表中对这个对象的引用就继续存在。依赖这个特性，当
程序已经跑过释放对象的逻辑后，如果这个表中还存在有这个对象的引用，那
么这个对象肯定就是泄漏了。